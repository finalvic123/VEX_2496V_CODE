#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    potenL,         sensorPotentiometer)
#pragma config(Sensor, in3,    potenR,         sensorPotentiometer)
#pragma config(Sensor, dgtl2,  encoderL1,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encoderR1,      sensorQuadEncoder)
#pragma config(Motor,  port1,           motorLM,       tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           motorLFB,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           liftBL,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           liftTL,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,            ,             tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           claw,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           liftTR,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftBR,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           motorRFB,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          motorRM,       tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
	SensorType[in1] = sensorGyro;
	wait1Msec(1500);
	SensorValue[gyro] = 0; //positive counterclockwise
	//SensorValue[in2] = 0;
	//SensorValue[in3] = 0;
	SensorValue[dgtl2] = 0;
	SensorValue[dgtl5] = 0;
	stopAllMotors();
	//moveL = SensorValue(encoderL1);
	//liftL = SensorValue(potenL);


	bStopTasksBetweenModes = false;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

void move(int moveSpeed)	//simple move function
{
	motor[motorLM] = moveSpeed;
	motor[motorLFB] = moveSpeed;
	motor[motorRM] = moveSpeed;
	motor[motorRFB] = moveSpeed;
}
void lift(int liftSpeed) //simple lift function
{
	motor[liftBL] = liftSpeed;
	motor[liftBR] = liftSpeed;
	motor[liftTL] = liftSpeed;
	motor[liftTR] = liftSpeed;
}
void rotate(int rotateSpeed) //positive clockwise
{
	motor[motorLM] = rotateSpeed;
	motor[motorLFB] = rotateSpeed;
	motor[motorRM] = -rotateSpeed;
	motor[motorRFB] = -rotateSpeed;
}
//	motor[claw] = clawSpeed;

task autonomous() //start from blue
{
	/*int leftSpeed = 0;
	int rightSpeed = 0;
	int liftSpeed = 0;	//positive clockwise (right thumb)
	int clawSpeed = 0;*/
	int intLiftL = 0;
	int intLiftR = 0;
	int step = 0; // to control the progress of autonomous
	int moveL = 0; //left side encoder
	int liftL = 0;
	int c = 0;
	int cCount = 0; //increase the stability of gyro
	int suplift = 15; //support the lifting when the mobile goal is lifted
	//SensorValue[in2] = 0;
	//SensorValue[in3] = 0;
	SensorValue[dgtl2] = 0;
	SensorValue[dgtl5] = 0;
	/*SensorType[in1] = sensorNone;
	SensorType[in1] = sensorGyro;
	SensorValue[gyro] = 0; //positive counterclockwise*/
	intLiftL = SensorValue[potenL];	//initial potentiometer value for the lifts
	intLiftR = SensorValue[potenR];
	stopAllMotors();
	wait(0.5);
	while(1)
	{
		moveL = SensorValue(encoderL1);	//the encoder for the movemment, moving towards mobile goal yields a negative value
		liftL = SensorValue(potenL);	//the potentiometer for lift, lifting up yields a positive value.
		c = SensorValue(in1);
		//for simplicity reason, use leftside potentiometer and leftside encoder as the reference to the movement and lift
		if(step == 0) //expand the robot
		{
			if(liftL < 1750)	//the whole program goes in steps under a large while loop.
			{
				lift(50);
			}
			else{
				lift(suplift); move(0); step = 100;
			}
		}
		else if(step == 100)
		{
			if(liftL > 1430)	//the variable to change if the mobile goal intake does not go low enough. 1430 is the sensor value.
			{
				lift(-40);
			}
			else{ lift(suplift); move(0); step = 1;}
		}
		else if(step == 1) //goes to the first mobile goal and lift
		{
			if(moveL > -720)
			{
				move(-100);
			}
			else if(liftL < 1600)
			{
				move(0);
				lift(100);
			}
			else{ step = 2; move(0); lift(suplift);}
		}
		else if(step == 2) //rotate from 0 to -1800 towards the blue zone
		{
			if(c > -1600) rotate(50);
			else if(c > -1700) rotate(30);
			else if(c < -2000) rotate(-30);
			else{ rotate(0); cCount++; wait(0.01);}
			if(cCount > 50)
			{
				rotate(0); step = 3; SensorValue[dgtl2] = 0; moveL = 0; cCount = 0;
			} //clear the moveL value everytime after rotation
		}
		else if(step == 3) //move back to 10 points zone and lower the mobile goal
		{
			if(moveL > -1065)	//if the first mobile goal is not put back into 10-point zone, back up more by changing this value
			{
				move(-110);
			}
			else if(liftL > 1550)
			{
				move(0);
				lift(-50);
			}
			else{ move(0); lift(0); step = 4; }
		}
		/////////////////////////////////////////////////////////////////first mobile goal finished
		else if(step == 4) //go to the center, preparing for rotation
		{
			if(liftL > 1500)
			{
				lift(-50);
			}
			else lift(0);
			if(moveL < -595)
			{
				move(100);
			}
			else{ move(0); lift(0); step = 5; }
		}
		else if(step == 5) //rotate from -1800 to 0 towards the second mobile goal
		{
			if(c < -130) rotate(-50);
			else if(c < -80) rotate(-30);
			else if(c > 250) rotate(30);
			else{ rotate(0); cCount++; wait(0.01);}
			if(cCount > 50)
			{
				rotate(0); step = 6; moveL = 0; SensorValue[dgtl2] = 0; cCount = 0;
			}
		}
		else if(step == 6) //move towards the second mobile goal and lift it
		{
			if(moveL > -1100)
			{
				move(-100);
			}
			else if(liftL < 1600)
			{
				move(0);
				lift(100);
			}
			else{ step = 7; lift(suplift); move(0);}
		}
		else if(step == 7) //move the second mobile goal to the red zone
		{
			if(moveL > -2100)
			{
				move(-100);
			}
			else if(liftL > 1550)
			{
				move(0);
				lift(-50);
			}
			else{ move(0); lift(suplift); step = 8; }
		}
		//////////////////////////////////////////////////////////////////////////////////second mobile goal finished
		else if(step == 8) //move towards the third mobile goal, preparing for rotation
		{
			if(moveL < -530)
			{
				move(80);
			}
			else{ move(0); step = 101; }
		}
		else if(step == 101) //lift the lift to avoid hitting the cone
		{
			if(liftL < 1850)
			{
				lift(70);
			}
			else{ lift(suplift); step = 9;}
		}
		else if(step == 9) //rotate from 0 to 900
		{
			if(c < 750) rotate(-50);
			else if(c < 800) rotate(-30);
			else if(c > 1100) rotate(30);
			else{ rotate(0); cCount++; wait(0.01);}
			if(cCount > 50)
			{
				rotate(0); step = 102; moveL = 0; SensorValue[dgtl2] = 0; cCount = 0;
			}
		}
		else if(step == 102)
		{
			if(moveL > -80)
			{
				move(-50);
			}
			else if(liftL > 1490)
			{
				move(0);
				lift(-40);
			}
			else{ move(0); step = 10; lift(0); }
		}
		else if(step == 10) //move towards the third mobile goal
		{
			if(moveL > -780)
			{
				move(-110);
			}
			else if(liftL < 1590)
			{
				move(0);
				lift(100);
			}
			else{ move(0); lift(suplift); step = 11; }
		}
		else if(step == 11) //rotate from 900 to 1800, towards the blue zone (20-point)
		{
			if(c < 1600) rotate(-50);
			else if(c < 1700) rotate(-30);
			else if(c > 2200) rotate(30);
			else{ rotate(0); cCount++; wait(0.01);}
			if(cCount > 50)
			{
				rotate(0); step = 12; moveL = 0; SensorValue[dgtl2] = 0; cCount = 0;
			}
		}
		else if(step == 12) //move the third mobile goal to the blue
		{
			if(moveL > -1000)
			{
				move(-70);
			}
			else{ move(0); step = 13; }
		}
		else if(step == 13) //rotate from 1800 to 2700, towards the center of zone
		{
			if(c < 2600) rotate(-50);
			else if(c < 2700) rotate(-30);
			else if(c > 3100) rotate(30);
			else{ rotate(0); cCount++; wait(0.01);}
			if(cCount > 50)
			{
				rotate(0); step = 14; moveL = 0; SensorValue[dgtl2] = 0; cCount = 0;
			}
		}
		else if(step == 14)//move to the center of the zone, preparing for rotation
		{
			if(moveL > -230)
			{
				move(-70);
			}
			else{move(0); step = 15; wait(0.3);}
		}
		else if(step == 15) //rotate from 2700 to 2000
		{
			if(c > 2200) rotate(50);
			else if(c > 2100) rotate(20);
			else if(c < 1600) rotate(-30);
			else{ rotate(0); cCount++; wait(0.01);}
			if(cCount > 50)
			{
				rotate(0); step = 16; SensorValue[dgtl2] = 0; moveL = 0; cCount = 0;
			} //clear the moveL value everytime after rotation
		}
		else if(step == 16) //move the mobile goal to the 20-point zone
		{
			if(moveL > -600)
			{
				move(-100);
			}
			else if(liftL > 1550)
			{
				move(0);
				lift(-50);
			}
			else{ move(0); lift(0); step = 17;}
		}
		else if(step == 17) //move back to the center of the zone
		{
			if(moveL < 0)
			{
				move(100);
			}
			else{ move(0); step = 99;} ///////////////////////////////////////////////////cut here
		}
		else if(step == 18) //rotate from 1800 to 2700, towards the left
		{
			if(c < 2600) rotate(-50);
			else if(c < 2700) rotate(-30);
			else if(c > 3100) rotate(30);
			else{ rotate(0); cCount++; wait(0.01);}
			if(cCount > 50)
			{
				rotate(0); step = 19; moveL = 0; SensorValue[dgtl2] = 0; cCount = 0;
			}
		}
		else if(step == 19) //move to the left, preparing for rotation
		{
			if(moveL < 300)
			{
				move(100);
			}
			else{ move(0); step = 20;}
		}
		else if(step == 20) //rotate from 2700 to 3600
		{
			if(c < 2600) rotate(-50);
			else if(c < 2700) rotate(-30);
			else if(c > 3100) rotate(30);
			else{ rotate(0); cCount++; wait(0.01);}
			if(cCount > 50)
			{
				rotate(0); step = 99; moveL = 0; SensorValue[dgtl2] = 0; cCount = 0;
			}
		}
		else if(step == 99)
		{
			stopAllMotors();
			break;
		}
	}
	/*starts with 0,1400,1429,0,0
	1.0,14001429,-780,-760
	2.lift:1535,1555
	3.turn: -1800, 1590,1610,-1330,-210
	4.goes back: -2225,-1035
	5.restatt: 0, 1450,1460,0,0
	6.goes back half way: +300, +300
	7.rotate: 830,-330
	8.goes back: -420, -1590
	9.lift
	10.goes back:-2035,-3375
	11.goes forware: 60, -1285 //step == 8
	12.rotate:370,-1495
	13.goes back: -45, -1920 //step == 10
	14.rotate:30,-2460
	15.goes bavk:-1210,-3680 //step == 12
	16.restart:0,0
	17.goes forward:460,475 //step == 14
	18.rotate:1150,40
	19.goes back:-500,-`1675
	20.goes back:-2045,-3100
	21.goes forward:-1690,-2750
	*/
}

task usercontrol()
{
	int leftSpeed = 0;
	int rightSpeed = 0;
	int liftSpeed = 0;	//positive clockwise (right thumb)
	int clawSpeed = 0;
	SensorType[in1] = sensorNone;
	SensorType[in1] = sensorGyro;
	SensorValue[gyro] = 0; //positive counterclockwise

	while(1)
	{
		leftSpeed = vexRT[Ch3];
		rightSpeed = vexRT[Ch2];
		motor[motorLM] = leftSpeed;
		motor[motorLFB] = leftSpeed;
		motor[motorRM] = rightSpeed;
		motor[motorRFB] = rightSpeed;
		if(vexRT[Btn5U] == 1) liftSpeed = 100;
		else if(vexRT[Btn5D] == 1) liftSpeed = -100;
		else liftSpeed = 0;
		if(vexRT[Btn6U] == 1) clawSpeed = 30;
		else if(vexRT[Btn6D] == 1) clawSpeed = -30;
		else clawSpeed = 0;
		motor[liftBL] = liftSpeed;
		motor[liftTL] = liftSpeed;
		motor[liftBR] = liftSpeed;
		motor[liftTR] = liftSpeed;
		motor[claw] = clawSpeed;
	}
}
